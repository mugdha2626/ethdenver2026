<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy"
        content="default-src 'self'; style-src 'unsafe-inline'; script-src 'unsafe-inline' https://cdn.jsdelivr.net; connect-src 'self'">
  <meta name="robots" content="noindex, nofollow">
  <title>Cloak — Secret</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    @keyframes hexDrift1 {
      0% { transform: translate(0, 0) rotate(0deg); opacity: 0.05; }
      50% { transform: translate(-30px, -40px) rotate(180deg); opacity: 0.08; }
      100% { transform: translate(0, 0) rotate(360deg); opacity: 0.05; }
    }

    @keyframes hexDrift2 {
      0% { transform: translate(0, 0) rotate(0deg); opacity: 0.06; }
      50% { transform: translate(40px, -30px) rotate(-180deg); opacity: 0.09; }
      100% { transform: translate(0, 0) rotate(-360deg); opacity: 0.06; }
    }

    @keyframes hexDrift3 {
      0% { transform: translate(0, 0) rotate(0deg); opacity: 0.04; }
      50% { transform: translate(-25px, 35px) rotate(180deg); opacity: 0.07; }
      100% { transform: translate(0, 0) rotate(360deg); opacity: 0.04; }
    }

    @keyframes shimmer {
      0% { transform: translateX(-150%); opacity: 0; }
      50% { opacity: 1; }
      100% { transform: translateX(150%); opacity: 0; }
    }

    @keyframes gradientShift {
      0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.6; }
      33% { transform: translate(30px, -40px) scale(1.1); opacity: 0.8; }
      66% { transform: translate(-40px, 30px) scale(0.95); opacity: 0.7; }
    }

    @keyframes meshMove {
      0%, 100% {
        background-position: 0% 50%;
      }
      50% {
        background-position: 100% 50%;
      }
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    body {
      background:
        radial-gradient(ellipse 800px 600px at 10% 20%, rgba(88, 28, 135, 0.35) 0%, transparent 50%),
        radial-gradient(ellipse 600px 800px at 90% 80%, rgba(139, 92, 246, 0.3) 0%, transparent 50%),
        radial-gradient(ellipse 700px 500px at 50% 50%, rgba(59, 130, 246, 0.2) 0%, transparent 50%),
        radial-gradient(ellipse 900px 700px at 30% 70%, rgba(168, 85, 247, 0.25) 0%, transparent 60%),
        linear-gradient(135deg, #0a0015 0%, #050510 25%, #000000 50%, #0a0520 75%, #050515 100%);
      background-size: 400% 400%;
      animation: meshMove 20s ease infinite;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2rem 1rem;
      font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', 'Courier New', monospace;
      position: relative;
      overflow-x: hidden;
    }

    /* Animated mesh overlay */
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-image:
        linear-gradient(rgba(139, 92, 246, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(139, 92, 246, 0.05) 1px, transparent 1px);
      background-size: 40px 40px;
      pointer-events: none;
      z-index: 1;
      opacity: 0.4;
    }


    /* Animated gradient orbs */
    .gradient-orb {
      position: fixed;
      border-radius: 50%;
      pointer-events: none;
      z-index: 0;
      filter: blur(80px);
      mix-blend-mode: screen;
    }

    .gradient-orb-1 {
      width: 600px;
      height: 600px;
      background: radial-gradient(circle, rgba(139, 92, 246, 0.5) 0%, rgba(139, 92, 246, 0) 70%);
      top: -200px;
      right: -200px;
      animation: gradientShift 15s ease-in-out infinite;
    }

    .gradient-orb-2 {
      width: 500px;
      height: 500px;
      background: radial-gradient(circle, rgba(59, 130, 246, 0.4) 0%, rgba(59, 130, 246, 0) 70%);
      bottom: -150px;
      left: -150px;
      animation: gradientShift 18s ease-in-out infinite;
      animation-delay: -6s;
    }

    .gradient-orb-3 {
      width: 450px;
      height: 450px;
      background: radial-gradient(circle, rgba(168, 85, 247, 0.35) 0%, rgba(168, 85, 247, 0) 70%);
      top: 40%;
      left: 40%;
      animation: gradientShift 20s ease-in-out infinite;
      animation-delay: -12s;
    }

    .gradient-orb-4 {
      width: 400px;
      height: 400px;
      background: radial-gradient(circle, rgba(99, 102, 241, 0.3) 0%, rgba(99, 102, 241, 0) 70%);
      top: 20%;
      right: 30%;
      animation: gradientShift 16s ease-in-out infinite;
      animation-delay: -4s;
    }

    /* Floating hexagons */
    .hex {
      position: fixed;
      color: rgba(139, 92, 246, 0.15);
      pointer-events: none;
      z-index: 1;
      font-size: 100px;
      line-height: 1;
    }

    .hex1 { top: 8%; right: 12%; animation: hexDrift1 22s ease-in-out infinite; }
    .hex2 { top: 55%; right: 5%; font-size: 70px; animation: hexDrift2 28s ease-in-out infinite; animation-delay: -5s; }
    .hex3 { top: 20%; left: 8%; font-size: 120px; animation: hexDrift3 25s ease-in-out infinite; animation-delay: -10s; }
    .hex4 { bottom: 15%; left: 12%; font-size: 80px; animation: hexDrift1 26s ease-in-out infinite; animation-delay: -15s; }
    .hex5 { top: 75%; left: 45%; font-size: 90px; animation: hexDrift2 30s ease-in-out infinite; animation-delay: -8s; }
    .hex6 { top: 40%; right: 30%; font-size: 60px; animation: hexDrift3 24s ease-in-out infinite; animation-delay: -12s; }

    .container {
      max-width: 700px;
      width: 100%;
      position: relative;
      z-index: 10;
    }

    h1 {
      color: #ffffff;
      font-size: 2.5rem;
      margin-bottom: 2.5rem;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 3px;
      font-weight: 700;
      text-shadow: 0 0 40px rgba(139, 92, 246, 0.6);
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1.5rem;
    }

    h1::before,
    h1::after {
      content: '⬢';
      font-size: 1rem;
      color: rgba(139, 92, 246, 0.7);
    }

    /* Glassmorphism cards */
    .glass-card {
      background: rgba(15, 15, 20, 0.7);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(139, 92, 246, 0.2);
      border-radius: 16px;
      box-shadow:
        0 8px 32px 0 rgba(0, 0, 0, 0.6),
        inset 0 1px 0 0 rgba(139, 92, 246, 0.1);
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }

    .glass-card:hover {
      border-color: rgba(139, 92, 246, 0.4);
      box-shadow:
        0 12px 48px 0 rgba(0, 0, 0, 0.7),
        0 0 30px rgba(139, 92, 246, 0.2);
    }

    .glass-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: -150%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(139, 92, 246, 0.1), transparent);
      animation: shimmer 4s ease-in-out infinite;
    }

    .loading {
      text-align: center;
      padding: 3rem 1rem;
    }

    .loading p {
      color: #b8c5d6;
      font-size: 0.95rem;
      margin-bottom: 0.5rem;
    }

    .spinner {
      display: inline-block;
      width: 32px;
      height: 32px;
      border: 3px solid rgba(139, 92, 246, 0.2);
      border-top-color: rgba(139, 92, 246, 1);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
      margin-bottom: 1rem;
      box-shadow: 0 0 10px rgba(139, 92, 246, 0.5);
    }

    .meta {
      margin-bottom: 2rem;
    }

    .meta-row {
      display: grid;
      grid-template-columns: 120px 1fr;
      gap: 1.5rem;
      padding: 1.1rem 1.8rem;
      border-bottom: 1px solid rgba(139, 92, 246, 0.1);
      transition: all 0.3s ease;
      position: relative;
    }

    .meta-row::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      width: 2px;
      background: rgba(139, 92, 246, 0.6);
      transform: scaleY(0);
      transition: transform 0.3s ease;
    }

    .meta-row:hover::before {
      transform: scaleY(1);
    }

    .meta-row:hover {
      background: rgba(139, 92, 246, 0.08);
      padding-left: 2rem;
    }

    .meta-row:last-child {
      border-bottom: none;
    }

    .meta-label {
      color: rgba(50, 100, 200, 1);
      font-size: 0.7rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .meta-label::before {
      content: '>';
      font-size: 0.7rem;
      opacity: 0.7;
    }

    .meta-value {
      color: rgba(255, 255, 255, 0.95);
      font-size: 0.85rem;
      font-weight: 400;
      word-break: break-word;
    }

    .meta-value.e2e {
      color: #4ade80;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .meta-value.e2e::before {
      content: '[✓]';
      font-size: 0.75rem;
    }

    .secret-box {
      margin-bottom: 2rem;
    }

    .secret-label {
      color: rgba(50, 100, 200, 1);
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      padding: 1.3rem 1.8rem 0.9rem;
      font-weight: 700;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      border-bottom: 1px solid rgba(139, 92, 246, 0.15);
    }

    .secret-label::before {
      content: '//';
      font-size: 0.9rem;
      opacity: 0.7;
    }

    .secret-content {
      font-size: 0.95rem;
      color: rgba(255, 255, 255, 1);
      white-space: pre-wrap;
      word-break: break-all;
      line-height: 1.8;
      padding: 1.3rem 1.8rem 1.5rem;
      position: relative;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 0 0 16px 16px;
      font-family: 'Courier New', 'Courier', monospace;
      font-weight: 600;
      letter-spacing: 0.3px;
    }

    .actions {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin-bottom: 2rem;
    }

    button {
      background: rgba(25, 25, 30, 0.8);
      backdrop-filter: blur(10px);
      color: rgba(255, 255, 255, 0.95);
      border: 1px solid rgba(139, 92, 246, 0.3);
      border-radius: 10px;
      padding: 0.95rem 1.5rem;
      font-size: 0.75rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1.5px;
      position: relative;
      overflow: hidden;
      font-family: inherit;
    }

    button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      border-radius: 50%;
      background: rgba(139, 92, 246, 0.4);
      transform: translate(-50%, -50%);
      transition: width 0.6s ease, height 0.6s ease;
    }

    button:hover::before {
      width: 300px;
      height: 300px;
    }

    button:hover {
      background: rgba(35, 35, 45, 0.9);
      border-color: rgba(139, 92, 246, 0.6);
      transform: translateY(-2px);
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
    }

    .btn-copy {
      background: rgba(139, 92, 246, 0.25);
      border: 1px solid rgba(139, 92, 246, 0.6);
    }

    .btn-copy:hover {
      background: rgba(139, 92, 246, 0.35);
      border-color: rgba(139, 92, 246, 0.8);
      box-shadow: 0 8px 32px rgba(139, 92, 246, 0.5);
    }

    .timer {
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.75rem;
      text-align: center;
      padding: 1.1rem;
      background: rgba(15, 15, 20, 0.6);
      backdrop-filter: blur(10px);
      border-radius: 10px;
      border: 1px solid rgba(139, 92, 246, 0.2);
      letter-spacing: 0.5px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
    }

    .timer::before {
      content: '[⬢]';
      font-size: 0.7rem;
      color: rgba(139, 92, 246, 0.7);
    }

    .cleared {
      text-align: center;
      padding: 4rem 2rem;
    }

    .cleared h2 {
      color: rgba(50, 100, 200, 1);
      font-size: 1.5rem;
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    .cleared h2::before {
      content: '✓ ';
      color: #4ade80;
    }

    .cleared p {
      color: #b8c5d6;
      font-size: 0.95rem;
      margin-bottom: 0.5rem;
    }

    .error-view {
      text-align: center;
      padding: 4rem 2rem;
    }

    .error-view h2 {
      color: #ff6b6b;
      font-size: 1.5rem;
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 2px;
      text-shadow: 0 0 10px rgba(255, 107, 107, 0.5);
    }

    .error-view h2::before {
      content: '⚠️ ';
    }

    .error-view p {
      color: #e0e6ed;
      font-size: 0.95rem;
      line-height: 1.6;
    }

    @media print {
      .secret-content { color: transparent !important; }
      .secret-content::after { content: '[REDACTED]'; color: #8b949e; }
    }

    @media (max-width: 768px) {
      h1 { font-size: 2rem; letter-spacing: 6px; }
      .meta-row { grid-template-columns: 1fr; gap: 0.5rem; }
      .actions { grid-template-columns: 1fr; }
      .hex { display: none; }
    }
  </style>
</head>
<body>
  <div class="gradient-orb gradient-orb-1"></div>
  <div class="gradient-orb gradient-orb-2"></div>
  <div class="gradient-orb gradient-orb-3"></div>
  <div class="gradient-orb gradient-orb-4"></div>

  <!-- Floating hexagons -->
  <div class="hex hex1">⬡</div>
  <div class="hex hex2">⬢</div>
  <div class="hex hex3">⬡</div>
  <div class="hex hex4">⬢</div>
  <div class="hex hex5">⬡</div>
  <div class="hex hex6">⬢</div>

  <div class="container" id="loading-view">
    <h1>CLOAK</h1>
    <div class="glass-card loading">
      <div class="spinner"></div>
      <p>Fetching secret from Canton ledger...</p>
    </div>
  </div>

  <div class="container" id="secret-view" style="display:none;">
    <h1>CLOAK</h1>
    <div class="glass-card meta" id="meta-section"></div>
    <div class="glass-card secret-box">
      <div class="secret-label">Secret</div>
      <div class="secret-content" id="secret-text"></div>
    </div>
    <div class="actions">
      <button class="btn-copy" id="copy-btn">Copy to Clipboard</button>
      <button id="clear-btn">Clear Now</button>
    </div>
    <div class="timer" id="timer">This page will auto-clear in 5 minutes.</div>
  </div>

  <div class="container glass-card cleared" id="cleared-view" style="display:none;">
    <h2>Secret Cleared</h2>
    <p>The secret has been removed from this page for your security.</p>
    <p>You can close this tab.</p>
  </div>

  <div class="container glass-card error-view" id="error-view" style="display:none;">
    <h2 id="error-title"></h2>
    <p id="error-message"></p>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/node-forge@1.3.1/dist/forge.min.js"></script>
  <script>
    (function() {
      'use strict';

      var useWebCrypto = !!(crypto && crypto.subtle);

      // --- Parse parameters from URL fragment ---
      var hash = window.location.hash.substring(1);

      // Clear fragment from address bar immediately (fragments never sent to servers,
      // but clear anyway to prevent shoulder-surfing or accidental sharing)
      try { history.replaceState(null, '', window.location.pathname); } catch(e) {}

      if (!hash) {
        showError('Missing Parameters', 'No viewing parameters were provided. Please use the link from your Slack DM.');
        return;
      }

      var params = {};
      hash.split('&').forEach(function(pair) {
        var parts = pair.split('=');
        if (parts.length === 2) {
          params[decodeURIComponent(parts[0])] = decodeURIComponent(parts[1]);
        }
      });

      var token = params.jwt;
      var contractId = params.cid;
      var templateId = params.tid;
      var party = params.party;

      if (!token || !contractId || !templateId || !party) {
        showError('Missing Parameters', 'The link is incomplete. Please use the link from your Slack DM.');
        return;
      }

      // --- Fetch secret from Canton (same-origin request) ---
      fetch('/v1/query', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer ' + token
        },
        body: JSON.stringify({
          templateIds: [templateId],
          query: { recipient: party }
        })
      })
      .then(function(res) {
        if (res.status === 401) {
          throw { type: 'auth', message: 'JWT expired or invalid. The viewing window (60 seconds) may have passed. Ask the sender to share the secret again.' };
        }
        if (!res.ok) {
          throw { type: 'server', message: 'Canton API returned status ' + res.status + '. Please try again.' };
        }
        return res.json();
      })
      .then(function(data) {
        // Null out JWT from memory
        token = null;

        if (!data.result || !Array.isArray(data.result)) {
          throw { type: 'data', message: 'Unexpected response format from Canton.' };
        }

        // Find the specific contract by ID
        var contract = null;
        for (var i = 0; i < data.result.length; i++) {
          if (data.result[i].contractId === contractId) {
            contract = data.result[i];
            break;
          }
        }

        if (!contract) {
          throw { type: 'notfound', message: 'The secret was not found. It may have been acknowledged or expired on the Canton ledger.' };
        }

        var payload = contract.payload;
        renderSecret(payload);
      })
      .catch(function(err) {
        // Null out JWT on error too
        token = null;

        if (err && err.type) {
          switch(err.type) {
            case 'auth':
              showError('Authentication Failed', err.message);
              break;
            case 'notfound':
              showError('Secret Not Found', err.message);
              break;
            default:
              showError('Error', err.message);
          }
        } else {
          showError('Connection Error', 'Could not connect to Canton ledger. Please check that the service is running and try again.');
        }
      });

      // --- IndexedDB helpers for E2E decryption ---
      var IDB_NAME = 'cloak-encryption-keys';
      var IDB_STORE = 'private-keys';

      function openIDB() {
        return new Promise(function(resolve, reject) {
          var req = indexedDB.open(IDB_NAME, 1);
          req.onupgradeneeded = function() {
            req.result.createObjectStore(IDB_STORE, { keyPath: 'party' });
          };
          req.onsuccess = function() { resolve(req.result); };
          req.onerror = function() { reject(req.error); };
        });
      }

      function getPrivateKey(db, partyId) {
        return new Promise(function(resolve, reject) {
          var tx = db.transaction(IDB_STORE, 'readonly');
          var store = tx.objectStore(IDB_STORE);
          var req = store.get(partyId);
          req.onsuccess = function() { resolve(req.result ? req.result.key : null); };
          req.onerror = function() { reject(req.error); };
        });
      }

      function b64ToBytes(b64) {
        var bin = atob(b64);
        var arr = new Uint8Array(bin.length);
        for (var i = 0; i < bin.length; i++) arr[i] = bin.charCodeAt(i);
        return arr;
      }

      // --- Forge-based decryption for non-secure contexts ---

      function forgeDecryptEnvelope(envelope, pemPrivateKey) {
        var forgeKey = forge.pki.privateKeyFromPem(pemPrivateKey);

        // RSA-OAEP decrypt the AES key
        var encryptedAesKeyBytes = forge.util.decode64(envelope.k);
        var rawAesKey = forgeKey.decrypt(encryptedAesKeyBytes, 'RSA-OAEP', {
          md: forge.md.sha256.create(),
          mgf1: { md: forge.md.sha256.create() }
        });

        // AES-GCM decrypt
        var cBytes = forge.util.decode64(envelope.c);
        var tBytes = forge.util.decode64(envelope.t);
        var ivBytes = forge.util.decode64(envelope.iv);

        var decipher = forge.cipher.createDecipher('AES-GCM', rawAesKey);
        decipher.start({
          iv: ivBytes,
          tag: forge.util.createBuffer(tBytes),
          tagLength: 128
        });
        decipher.update(forge.util.createBuffer(cBytes));
        var pass = decipher.finish();
        if (!pass) throw new Error('AES-GCM auth tag mismatch — decryption failed');

        return decipher.output.toString('utf8');
      }

      // ---------------------------------------------------------------

      async function decryptSecret(encryptedSecretB64, partyId) {
        // Try to parse as encrypted envelope
        var envelopeJson;
        try {
          envelopeJson = atob(encryptedSecretB64);
        } catch (e) {
          // Not base64 — treat as plaintext (legacy)
          return { plaintext: encryptedSecretB64, encrypted: false };
        }

        var envelope;
        try {
          envelope = JSON.parse(envelopeJson);
        } catch (e) {
          // Not JSON — treat as plaintext (legacy)
          return { plaintext: encryptedSecretB64, encrypted: false };
        }

        if (!envelope || envelope.v !== 1) {
          // Not our encryption format — treat as plaintext (legacy)
          return { plaintext: encryptedSecretB64, encrypted: false };
        }

        // It's encrypted — need private key from IndexedDB
        var db = await openIDB();
        var privateKey = await getPrivateKey(db, partyId);
        if (!privateKey) {
          throw { type: 'nokeys', message: 'Encryption keys not found. Open this link on the device/browser where you registered and set up your keys.' };
        }

        // Detect key type: PEM string (forge) vs CryptoKey (Web Crypto)
        if (typeof privateKey === 'string') {
          // Forge path — key was generated via forge on HTTP
          var plaintext = forgeDecryptEnvelope(envelope, privateKey);
          return { plaintext: plaintext, encrypted: true };
        }

        // Web Crypto path — key is a CryptoKey object
        var encryptedAesKey = b64ToBytes(envelope.k);
        var rawAesKey = await crypto.subtle.decrypt(
          { name: 'RSA-OAEP' }, privateKey, encryptedAesKey
        );

        // Import raw AES key
        var aesKey = await crypto.subtle.importKey(
          'raw', rawAesKey, { name: 'AES-GCM' }, false, ['decrypt']
        );

        // Reconstruct ciphertext + authTag (Web Crypto AES-GCM expects them concatenated)
        var cBytes = b64ToBytes(envelope.c);
        var tBytes = b64ToBytes(envelope.t);
        var ivBytes = b64ToBytes(envelope.iv);

        var combined = new Uint8Array(cBytes.length + tBytes.length);
        combined.set(cBytes, 0);
        combined.set(tBytes, cBytes.length);

        // AES-GCM decrypt
        var plainBuffer = await crypto.subtle.decrypt(
          { name: 'AES-GCM', iv: ivBytes, tagLength: 128 },
          aesKey, combined
        );

        var plaintext = new TextDecoder().decode(plainBuffer);
        return { plaintext: plaintext, encrypted: true };
      }

      // --- Render the secret in the DOM ---
      async function renderSecret(payload) {
        var metaSection = document.getElementById('meta-section');

        var rows = [
          { label: 'Label', value: payload.label },
          { label: 'Description', value: payload.description },
          { label: 'From', value: payload.sender },
          { label: 'Sent', value: payload.sentAt }
        ];

        if (payload.expiresAt) {
          rows.push({ label: 'Expires', value: payload.expiresAt });
        }

        rows.forEach(function(row) {
          var div = document.createElement('div');
          div.className = 'meta-row';

          var labelSpan = document.createElement('span');
          labelSpan.className = 'meta-label';
          labelSpan.textContent = row.label;

          var valueSpan = document.createElement('span');
          valueSpan.className = 'meta-value';
          valueSpan.textContent = row.value || '';

          div.appendChild(labelSpan);
          div.appendChild(valueSpan);
          metaSection.appendChild(div);
        });

        // Attempt E2E decryption
        try {
          var result = await decryptSecret(payload.encryptedSecret, party);
          document.getElementById('secret-text').textContent = result.plaintext;

          if (result.encrypted) {
            // Add E2E badge to meta
            var badgeDiv = document.createElement('div');
            badgeDiv.className = 'meta-row';
            var badgeLabel = document.createElement('span');
            badgeLabel.className = 'meta-label';
            badgeLabel.textContent = 'Encryption';
            var badgeValue = document.createElement('span');
            badgeValue.className = 'meta-value e2e';
            badgeValue.textContent = 'End-to-end encrypted';
            badgeDiv.appendChild(badgeLabel);
            badgeDiv.appendChild(badgeValue);
            metaSection.appendChild(badgeDiv);
          }
        } catch (err) {
          if (err && err.type === 'nokeys') {
            showError('Encryption Keys Not Found', err.message);
            return;
          }
          // Decryption failed — show error
          showError('Decryption Failed', 'Could not decrypt the secret. ' + (err.message || 'The encryption keys may not match.'));
          return;
        }

        // Show the secret view, hide loading
        document.getElementById('loading-view').style.display = 'none';
        document.getElementById('secret-view').style.display = 'block';

        // Start auto-clear timer
        startAutoClear();
      }

      // --- Auto-clear logic ---
      var AUTO_CLEAR_MS = 5 * 60 * 1000;
      var startTime = Date.now();
      var cleared = false;
      var autoTimer = null;

      function clearPage() {
        if (cleared) return;
        cleared = true;
        document.getElementById('loading-view').style.display = 'none';
        document.getElementById('secret-view').style.display = 'none';
        document.getElementById('error-view').style.display = 'none';
        document.getElementById('cleared-view').style.display = 'block';
        try { history.replaceState(null, '', window.location.pathname); } catch(e) {}
      }

      function startAutoClear() {
        startTime = Date.now();
        autoTimer = setTimeout(clearPage, AUTO_CLEAR_MS);

        // Update countdown
        setInterval(function() {
          if (cleared) return;
          var remaining = AUTO_CLEAR_MS - (Date.now() - startTime);
          if (remaining <= 0) return;
          var mins = Math.floor(remaining / 60000);
          var secs = Math.floor((remaining % 60000) / 1000);
          document.getElementById('timer').textContent =
            'This page will auto-clear in ' + mins + 'm ' + secs + 's.';
        }, 1000);
      }

      // Clear on tab switch
      document.addEventListener('visibilitychange', function() {
        if (document.hidden && !cleared && document.getElementById('secret-view').style.display !== 'none') {
          clearPage();
        }
      });

      // Redact on print
      window.addEventListener('beforeprint', function() {
        var el = document.getElementById('secret-text');
        if (el) el.textContent = '[REDACTED]';
      });

      // Copy button
      document.getElementById('copy-btn').addEventListener('click', function() {
        if (cleared) return;
        var text = document.getElementById('secret-text').textContent;
        navigator.clipboard.writeText(text).then(function() {
          var btn = document.getElementById('copy-btn');
          btn.textContent = 'Copied!';
          setTimeout(function() { btn.textContent = 'Copy to Clipboard'; }, 2000);
        });
      });

      // Clear now button
      document.getElementById('clear-btn').addEventListener('click', function() {
        if (autoTimer) clearTimeout(autoTimer);
        clearPage();
      });

      // --- Error display ---
      function showError(title, message) {
        document.getElementById('loading-view').style.display = 'none';
        document.getElementById('error-title').textContent = title;
        document.getElementById('error-message').textContent = message;
        document.getElementById('error-view').style.display = 'block';
      }
    })();
  </script>
</body>
</html>
